Your antivirus squad is up against a particularly sadistic bit of malicious code  that’s hijacked your mainframe. What you’ve learned from other infected systems— right before they went dark— is that it likes to toy with antivirus agents in a very peculiar way. It corrupts one of the 4 disks that run your mainframe, represented by lights showing which are on and which off. Then it selects one member of the antivirus squad— this’ll be you— and brings them into the mainframe. It tells them which disk it corrupted, allows the agent to switch a single disk on or off, then immediately de-rezzes the agent. Your squad can make an all-out attack to break into the mainframe and destroy one disk  before they’re wiped out. If they destroy the corrupted one,  the malware will be defeated. Any others, and the virus will erase  the entire system. The lights are only visible  within the mainframe, so you won’t know until you get there  which, if any, are on. How can you communicate,  with your single action, which of the 4 disks has been corrupted? Pause here to figure it out for yourself. Answer in 3 Answer in 2 Answer in 1 The setting is a big clue  for one solution. Using binary code— the base two  numbering system that only uses 1s and 0s— we can represent each of the 4 disks with a 2-bit binary number ranging from 00 for zero to 11 for three. What we’re looking for now is some sort of mathematical operation that can take the lit disks as input,  and give the corrupted disk as an output. Let’s consider one possibility. Say that the corrupted disk was this one, and when you come in, no lights are on. You could turn 11 on  to indicate that disk. Okay, what if you came in  and 11 was already on? You have to switch one light. Which seems like the most innocuous  to change? Probably 00,  in that if you were to add 00 and 11, you’d still get 11. So maybe the key is to think of addition of binary numbers, with the sum of the lit disks  communicating the corrupted disk number. This works great, until we start  with a different hypothetical. What if 00 was the corrupted disk,  and 01 and 10 were on? Here, the sum of the lit disks is 11. But we need to change this to a sum  of 00 with the flip of one switch. We have four options:  turning switch 00 on gives us 11. Turning 01 off takes us back to 10, and turning 10 off gives 01. None of those work. Turning switch 11 on gives us 110  by standard binary addition. But we don’t really want three digit numbers. So what if— to keep the result a two digit number— we break the rules a bit  and let this sum equal 22. That’s not a binary number,  but if we regard 2s as the same as 0s, that does indicate the correct disk. So this suggests a strategy: look at the sum of all the lighted disks we see, regarding 2s as 0s. If it’s already the correct result, flip 00, and if not, find the switch that will make the sum correct. You can see for yourself that any  starting configuration can sum to any number from 00 to 11 with a flip of a switch. The reason this works is related to a concept called parity. Parity tells you whether a given value is even or odd. In this case, the values whose parity we’re considering are the number of 1s in each digit place  of our binary sums. And that’s why we can say that 2 and 0, both even numbers, can be treated as equivalents. By adding or subtracting 00, 01, 10, or 11, we can change the parity of either, both, or neither digit, and create the disk number we want. What’s incredible about this solution is that it works for any mainframe whose disks are a power of two. With 64 you could turn each activated disk into a 6-bit binary number and sum the 1s in each column, regarding any even sum as the same as 0  and any odd sum as 1. 1,048,576 disks would be daunting,  but entirely doable. Luckily, your mainframe is much smaller. You make the valiant sacrifice and your team rushes in, destroying the corruption and freeing the system.